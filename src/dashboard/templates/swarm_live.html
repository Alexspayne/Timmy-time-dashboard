{% extends "base.html" %}

{% block title %}{{ page_title }}{% endblock %}

{% block content %}
<div class="card">
    <div class="card-header">
        <h2 class="card-title">ðŸ”´ Live Swarm Dashboard</h2>
        <div>
            <span class="badge badge-success" id="connection-status">Connecting...</span>
        </div>
    </div>
    
    <div class="grid grid-3" style="margin-bottom: 20px;">
        <div class="stat">
            <div class="stat-value" id="stat-agents">-</div>
            <div class="stat-label">Total Agents</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="stat-active">-</div>
            <div class="stat-label">Active</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="stat-tasks">-</div>
            <div class="stat-label">Active Tasks</div>
        </div>
    </div>
    
    <div class="grid grid-2">
        <div>
            <h3 style="margin-bottom: 12px;">Agents</h3>
            <div id="agents-list">
                <p style="color: var(--text-muted);">Loading agents...</p>
            </div>
        </div>
        <div>
            <h3 style="margin-bottom: 12px;">Active Auctions</h3>
            <div id="auctions-list">
                <p style="color: var(--text-muted);">Loading auctions...</p>
            </div>
        </div>
    </div>
    
    <div style="margin-top: 20px;">
        <h3 style="margin-bottom: 12px;">Swarm Log</h3>
        <div id="swarm-log" style="height: 200px; overflow-y: auto; background: var(--bg-tertiary); padding: 12px; border-radius: 8px; font-family: monospace; font-size: 0.875rem;">
            <div style="color: var(--text-muted);">Waiting for updates...</div>
        </div>
    </div>
</div>

<script>
let ws = null;
let reconnectInterval = 1000;
const maxReconnectInterval = 30000;

function connect() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${protocol}//${window.location.host}/swarm/live`);
    
    ws.onopen = function() {
        console.log('WebSocket connected');
        document.getElementById('connection-status').textContent = 'Live';
        document.getElementById('connection-status').className = 'badge badge-success';
        reconnectInterval = 1000;
        addLog('Connected to swarm', 'success');
    };
    
    ws.onmessage = function(event) {
        const message = JSON.parse(event.data);
        handleMessage(message);
    };
    
    ws.onclose = function() {
        console.log('WebSocket disconnected');
        document.getElementById('connection-status').textContent = 'Reconnecting...';
        document.getElementById('connection-status').className = 'badge badge-warning';
        addLog('Disconnected, reconnecting...', 'warning');
        
        setTimeout(connect, reconnectInterval);
        reconnectInterval = Math.min(reconnectInterval * 2, maxReconnectInterval);
    };
    
    ws.onerror = function(error) {
        console.error('WebSocket error:', error);
        addLog('Connection error', 'error');
    };
}

function handleMessage(message) {
    // Handle structured state snapshots (initial_state / state_update)
    if (message.type === 'initial_state' || message.type === 'state_update') {
        const data = message.data;
        document.getElementById('stat-agents').textContent = data.agents.total;
        document.getElementById('stat-active').textContent = data.agents.active;
        document.getElementById('stat-tasks').textContent = data.tasks.active;
        updateAgentsList(data.agents.list);
        updateAuctionsList(data.auctions.list);
        return;
    }

    // Handle individual swarm events broadcast by ws_manager
    const evt = message.event || message.type || '';
    const data = message.data || message;

    if (evt === 'agent_joined') {
        addLog('Agent joined: ' + (data.name || data.agent_id || ''), 'success');
        refreshStats();
    } else if (evt === 'agent_left') {
        addLog('Agent left: ' + (data.name || data.agent_id || ''), 'warning');
        refreshStats();
    } else if (evt === 'task_posted') {
        addLog('Task posted: ' + (data.description || data.task_id || '').slice(0, 60), 'info');
        refreshStats();
    } else if (evt === 'bid_submitted') {
        addLog('Bid: ' + (data.agent_id || '').slice(0, 8) + ' bid ' + (data.bid_sats || '?') + ' sats', 'info');
    } else if (evt === 'task_assigned') {
        addLog('Task assigned to ' + (data.agent_id || '').slice(0, 8), 'success');
        refreshStats();
    } else if (evt === 'task_completed') {
        addLog('Task completed by ' + (data.agent_id || '').slice(0, 8), 'success');
        refreshStats();
    }
}

function refreshStats() {
    // Fetch current swarm status via REST and update the stat counters
    fetch('/swarm').then(r => r.json()).then(data => {
        document.getElementById('stat-agents').textContent = data.agents || 0;
        document.getElementById('stat-active').textContent = data.agents_busy || 0;
        document.getElementById('stat-tasks').textContent = (data.tasks_pending || 0) + (data.tasks_running || 0);
    }).catch(() => {});
}

// Safe text setter â€” avoids XSS when inserting user/server data into DOM
function _t(el, text) { el.textContent = text; return el; }
function _el(tag, cls) { const e = document.createElement(tag); if (cls) e.className = cls; return e; }

function updateAgentsList(agents) {
    const container = document.getElementById('agents-list');
    container.innerHTML = '';

    if (!agents || agents.length === 0) {
        const p = _el('p'); p.style.color = 'var(--text-muted)';
        _t(p, 'No agents registered');
        container.appendChild(p);
        return;
    }

    agents.forEach(agent => {
        const card = _el('div', 'agent-card');
        const avatar = _el('div', 'agent-avatar');
        _t(avatar, (agent.name || '?').charAt(0).toUpperCase());
        const info = _el('div', 'agent-info');
        const name = _el('div', 'agent-name');
        _t(name, agent.name || '');
        const desc = _el('div', 'agent-meta');
        _t(desc, agent.description || 'No description');
        const meta = _el('div', 'agent-meta');
        const badge = _el('span', `badge badge-${agent.status === 'active' ? 'success' : agent.status === 'busy' ? 'warning' : 'danger'}`);
        _t(badge, agent.status || '');
        const stats = _el('span');
        _t(stats, ` ${agent.min_bid ?? 0} sats min bid | ${agent.tasks_completed ?? 0} tasks | ${agent.total_earned ?? 0} sats earned`);
        meta.appendChild(badge);
        meta.appendChild(stats);
        info.appendChild(name);
        info.appendChild(desc);
        info.appendChild(meta);
        card.appendChild(avatar);
        card.appendChild(info);
        container.appendChild(card);
    });
}

function updateAuctionsList(auctions) {
    const container = document.getElementById('auctions-list');
    container.innerHTML = '';

    if (!auctions || auctions.length === 0) {
        const p = _el('p'); p.style.color = 'var(--text-muted)';
        _t(p, 'No active auctions');
        container.appendChild(p);
        return;
    }

    auctions.forEach(auction => {
        const card = _el('div', 'agent-card');
        const info = _el('div', 'agent-info');
        const name = _el('div', 'agent-name');
        _t(name, 'Task ' + String(auction.task_id || '').slice(0, 8));
        const meta = _el('div', 'agent-meta');
        _t(meta, `${Math.round(auction.time_remaining ?? 0)}s remaining | ${auction.bid_count ?? 0} bids`);
        info.appendChild(name);
        info.appendChild(meta);
        card.appendChild(info);
        container.appendChild(card);
    });
}

function addLog(message, type = 'info') {
    const log = document.getElementById('swarm-log');
    const timestamp = new Date().toLocaleTimeString();
    const color = type === 'error' ? 'var(--danger)' : type === 'warning' ? 'var(--warning)' : type === 'success' ? 'var(--success)' : 'var(--text-secondary)';
    
    const entry = document.createElement('div');
    entry.style.marginBottom = '4px';
    const tsSpan = _el('span');
    tsSpan.style.color = 'var(--text-muted)';
    _t(tsSpan, '[' + timestamp + '] ');
    const msgSpan = _el('span');
    msgSpan.style.color = color;
    _t(msgSpan, message);
    entry.appendChild(tsSpan);
    entry.appendChild(msgSpan);
    
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

// Connect on load
connect();
</script>
{% endblock %}
